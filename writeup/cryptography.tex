% vim:ft=tex
% TODO: some kind of intro thingy idk

Cryptography is the mathematical study of secure computation. In a computation,
we want to use \emph{protocols} to transform \emph{resources}. For the
computation to be secure, it must successfully resist \emph{attacks} by
\emph{adversaries}. We will make all of these notions precise, but first we
discuss a motivating example.\note{Many more examples can be found in any
	introductory text on cryptography, such as~\cite{katz-lindell-2014, rosulek-2021,
		pass-shelat-2020}.}

\section{Commitment Protocols}

Suppose we want to build an online rock-paper-scissors game. Two players, Alice
and Bob, should both be able to send each other a move and so determine the
winner. However, something needs to prevent the players from waiting until after
they learn the other's move to choose their own move. This is an ideal use-case
for a \emph{commitment protocol}.

Informally, a commitment protocol proceeds as follows. The sender $S$ has a
message $m$ that they wish to commit to---in our case, $m$ is one of
$\{R,P,S\}$. In the \emph{commit phase}, they send a commitment $c$ to the
receiver $R$. At some later time, $S$ may reveal $m$---plus maybe some auxillary
data, for example their random bits---to $R$, in which case $R$ should be able
to verify that $c$ was indeed a commitment to $m$.

We can formalize commitment schemes as follows:

\begin{dfn}[commitment protocol]\label{def:commitment protocol}
	A \emph{commitment protocol} consists of the following data:
	\begin{itemize}
		\item the \emph{message space} $\cM$ and \emph{commit space} $\cC$;
		\item a pair of families of probabalistic interactive algorithms\note{We
			      have been imprecise about our formal notion of algorithm. For our
			      purposes in this chapter, Turing machines suffice; we will be more
			      precise about this later. In particular, it will be important that we
			      consider the security parameter as indexing a family of algorithms, rather
			      than as a unary input to each algorithm as is common in the literature.}
		      $S_n$ and $R_n$ (indexed by the
		      \emph{security parameter} $n\in\NN$), respectively called the \emph{sender}
		      and \emph{receiver}, such that:
		      \begin{itemize}
			      \item in the \emph{commit phase}, $S_n$ gets $m\in\cM$ and returns
			            $c\in\cC$, while $R_n$ returns $\bot$ or $\top$;
			      \item in the \emph{reveal phase}, $S_n$ gets $m\in\cM$, while $R_n$
			            gets $c\in\cC$, returning $\bot$ or $m'\in\cM$.
		      \end{itemize}
	\end{itemize}
\end{dfn}

\begin{ntn}
	Let $S$ and $R$ be interactive algorithms as in \Cref{def:commitment
		protocol}.\begin{itemize}
		\item	We will write $\alg{Com}_S^R(m)$ for the output of $S$
		      in the commit phase with $S$ getting input $m\in\cM$, or $\bot$ if $R$
		      returns $\bot$.
		\item We will write $\alg{Rev}_S^R(m; c)$
		      for the output of $R$ in the reveal phase with $S$ getting input
		      $m\in\cM$ and $R$ getting input $c\in\cC$.

		      Where $S$ and $R$ are clear, we may omit the respective annotations.
	\end{itemize}
\end{ntn}

\noindent
We would like the commitment scheme to be correct, in that when the parties
behave honestly according to the protocol, the receiver returns the correct
message. Formally:
\begin{dfn}
	A commitment protocol $(S_n,R_n)$\note{When $n$ is unbound, we use this
		notation to indicate a family of pairs $\{(S_n,R_n):n\in\NN\}$; when $n$ is bound it refers
		to the specific pair $(S_n,R_n)$.} is \emph{correct} if for all $n\in\NN$ and
	$m\in\cM$, \[
		\Pr[\alg{Rev}_{S_n}^{R_n}(m; \alg{Com}_{S_n}^{R_n}(m)) = m] = 1.
	\]
\end{dfn}

\noindent
Given a commitment protocol $(S_n,R_n)$, we should be able to define a family of
algorithms for our rock-paper-scissors game as follows. Let $\cM = \{R,P,S\}$
and let $W: (\bot\sqcup\cM)^2\rightarrow\{1,0,-1,\bot\}$ compute whether the
first argument beats, ties, or loses to the second, propagating any $\bot$s.

% TODO: the notation here is a little ambiguous; in particular it's not completely
% clear who has views into what. We could clean it up at the cost of notational
% overhead,but it's also pretty clear from context.
\begin{prot}{Rock-Paper-Scissors}\label{prot:rock-paper-scissors}
	\item $A_n$ receives input $a\in\cM$; $B_n$ receives input $b\in\cM$.
	\item $A_n$ acts as $S_n$ and $B_n$ as $R_n$ to compute $c_a = \alg{Com}_{S_n}^{R_n}(a)$.
	\item $A_n$ acts as $R_n$ and $B_n$ as $S_n$ to compute $c_b = \alg{Com}_{S_n}^{R_n}(b)$.
	\item $A_n$ acts as $S_n$ and $B_n$ as $R_n$ to compute $a' = \alg{Rev}_{S_n}^{R_n}(a;c_a)$.
	\item $A_n$ acts as $R_n$ and $B_n$ as $S_n$ to compute $b' = \alg{Rev}_{S_n}^{R_n}(b;c_b)$.
	\item $A_n$ returns $W(a,b')$.
	\item $B_n$ returns $W(a',b)$.
\end{prot}

\begin{ntn}
	Given some fixed commitment protocol, we will write
	$\alg{RPS}_{A}^{B}(a,b)$ for the results returned by $A$ and $B$,
	respectively. If $A$ or $B$ are honest, we will omit the corresponding
	annotation.
\end{ntn}

\noindent
As with commitment, we can define correctness of this protocol.
\begin{dfn}
	\Cref{prot:rock-paper-scissors} is \emph{correct} relative to a commitment
	protocol $(S_n,R_n)$ if for all $a,b\in\{R,P,S\}$,
	\[
		\Pr[\alg{RPS}(a, b) = (W(a,b), W(a,b))] = 1.
	\]
\end{dfn}

\begin{thm}
	\Cref{prot:rock-paper-scissors} is correct relative to any correct commitment
	protocol.
\end{thm}

\begin{proof}
	Fix a correct commitment protocol. Then \begin{align*}
		 & \Pr[\alg{RPS}(a,b) = (W(a,b),W(a,b))]                                     \\
		 & = \Pr[W(a,b') = W(a,b)\text{ and }W(a',b) = W(a,b)]                       \\
		 & = \Pr[W(a,b') = W(a,b)]\cdot\Pr[W(a',b) = W(a,b)]                         \\
		 & \geq \Pr[b'=b]\cdot\Pr[a'=a]                                              \\
		 & = \Pr[\alg{Rev}(b;c_b)=b]\cdot\Pr[\alg{Rev}(a; c_a) = a]                  \\
		 & = \Pr[\alg{Rev}(b;\alg{Com}(b))=b]\cdot\Pr[\alg{Rev}(a;\alg{Com}(a)) = a] \\
		 & = 1.\qedhere
	\end{align*}
\end{proof}

\noindent
Furthermore,
At least in this case, it was easy to define notions of correctness that
compose. Our task now is to define security of commitment and
rock-paper-scissors such that, whenever a commitment scheme is secure,
\Cref{prot:rock-paper-scissors} is likewise secure.

\section{Game-Based Security}

In \emph{game-based} approaches to security, we define security by determining
the winner of an abstract game. Here, we encode specific properties we want the
algorithm to have, and say that an adversary wins the game if they can break the
property. In standard approaches to
commitment\note{See~\cites[Section 4.4.1]{canetti-2008,goldreich-2001}.}, there are two
desirable properties. \emph{Hiding} means that the receiver should not learn
anything about the message until the reveal phase. \emph{Binding} means that the
sender should not be able to trick the receiver into anything other than the
committed message. Formally:

\begin{dfn}\label{def:game commitment}
	A commitment scheme $(S_n, R_n)$ is \emph{game-secure} if the following hold.
	\begin{itemize}
		\item \emph{Hiding:} consider the following game against a family of
		      adversaies $R'_n$.
		      \begin{game}\label{game:hiding}
			      \item $R'_n$ outputs $m_0,m_1\in \cM$.
			      \item A random bit $b\in\{0,1\}$ is chosen; $m_b$ is given to $S_n$.
			      \item $S_n$ and $R'_n$ participate in the commitment phase.
			      \item $R'_n$ outputs a guess $b'\in\{0, 1\}$. $R'_n$ wins if $b' =
				      b$.
		      \end{game}
		      A commitment scheme is \emph{hiding} if for any family of
		      probabalistic polynomial-time algorithms $R'_n$, \[
			      \Pr[R'_n\text{ wins \Cref{game:hiding}}] \leq \frac{1}{2} + \negl.
		      \]
		      The idea is that $R'_n$ participates in the commitment phase for a randomly
		      chosen message $m_b$, and then tries to guess $b$; they should be able
		      to guess no more than negligibly\note{A function is \emph{negligible},
			      written $\negl$, if it is asymptotically smaller than any rational
			      function in $n$.} better than random.
		\item \emph{Binding:} consider the following game against a family of
		      adversaires $S'_n$.
		      \begin{game}\label{game:binding}
			      \item $S'_n$ outputs $m_0,m_1\in\cM$.
			      \item $S'_n$ and $R_n$ participate in the commitment phase.
			      \item A random bit $b\in\{0,1\}$ is chosen and given to $S'_n$.
			      \item $S'_n$ and $R_n$ participate in the reveal phase.
			      \item $S'_n$ wins if $R_n$ outputs $m_b$.
		      \end{game}

		      A commitment scheme is \emph{binding} if for any family of
		      probabalistic polynomial-time algorithms $S'_n$, \[
			      \Pr[S'_n\text{ wins \Cref{game:binding}}] \leq \frac{1}{2} + \negl.
		      \]
		      The idea is that $S'_n$ first makes a commitment, and then learns
		      which of two messages they want to reveal to $R_n$; they should be
		      able to do no more than negligibly better than guessing which of the
		      two messages to commit to before learning the random bit.
	\end{itemize}
\end{dfn}

\noindent
Similarly, we can define security of \Cref{prot:rock-paper-scissors} by having
the adversary play against an honest party who moves uniform at random.

\begin{dfn}
	\Cref{prot:rock-paper-scissors} is \emph{game-secure} relative to a commitment
	protocol $(S_n,R_n)$ if the following hold:
	\begin{itemize}
		\item \emph{A-security}: For any family of PPT\note{Probabalistic
			      polynomial-time, though this definition can be made relative to any class
			      of adversarial algorithms.} algorithms $A'_n$,\[
			      \Pr[\pr_2(\alg{RPS}_{A'_n}(a,b)) = 1] \leq \frac{1}{3} + \negl,
		      \]
		      where the randomness is over uniform choice of $a,b\in\cM$.
		\item \emph{B-security}: For any family of PPT algorithms $B'_n$,\[
			      \Pr[\pr_1(\alg{RPS}^{B'_n}(a,b)) = -1] \leq \frac{1}{3} + \negl,
		      \]
		      where the randomness is over uniform choice of $a,b\in\cM$.
	\end{itemize}
\end{dfn}

\noindent
In particular, when the adversary controls $A$, we care only that $B$ outputs a
fair view of the game, and when the adversary controls $B$, we only care that
$A$ outputs a fair view of the game: we can never prevent the adversary from
just outputting that they win.

\section{Simulation-Based Security}

In \emph{simulation-based} approaches to security, we define security by
comparing a protocol in the real world to an ideal world in which the desired
resource is produced by a trusted black-box.
