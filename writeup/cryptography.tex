% vim:ft=tex
% TODO: some kind of intro thingy idk

Cryptography is the mathematical study of secure computation. In a computation,
we want to use \emph{protocols} to transform \emph{resources}. For the
computation to be secure, it must successfully resist \emph{attacks} by
\emph{adversaries}. We will make all of these notions precise, but first we
discuss a motivating example.\footnote{Many more examples can be found in any
	introductory text on cryptography, such as~\cite{katz-lindell-2014, rosulek-2021,
		pass-shelat-2020}.}

\section{Commitment Protocols}

Suppose we want to build an online rock-paper-scissors game. Two players, Alice
and Bob, should both be able to send each other a move and so determine the
winner. However, something needs to prevent the players from waiting until after
they learn the other's move to choose their own move. This is an ideal use-case
for a \emph{commitment protocol}.

Informally, a commitment protocol proceeds as follows. The sender $S$ has a
message $m$ that they wish to commit to---in our case, $m$ is one of
$\{R,P,S\}$. In the \emph{commit phase}, they send a commitment $c$ to the
receiver $R$. At some later time, $S$ may reveal $m$---plus maybe some auxillary
data, for example their random bits---to $R$, in which case $R$ should be able
to verify that $c$ was indeed a commitment to $m$.

We can formalize commitment schemes as follows:

\begin{dfn}[commitment protocol]\label{def:commitment protocol}
	A \emph{commitment protocol} consists of the following data:
	\begin{itemize}
		\item the \emph{message space} $\cM$ and \emph{commit space} $\cC$;
		\item a pair of families of probabalistic interactive algorithms\footnote{We
			      have been imprecise about our formal notion of algorithm. For our
			      purposes in this chapter, Turing machines suffice; we will be more
			      precise about this later. In particular, it will be important that we
			      consider the security parameter as indexing a family of algorithms, rather
			      than as a unary input to each algorithm as is common in the literature.}
		      $S_n$ and $R_n$ (indexed by the
		      \emph{security parameter} $n\in\NN$), respectively called the \emph{sender}
		      and \emph{receiver}, such that:
		      \begin{itemize}
			      \item in the \emph{commit phase}, $S_n$ gets $m\in\cM$ and returns
			            $c\in\cC$, while $R_n$ returns $\bot$ or $\top$;
			      \item in the \emph{reveal phase}, $S_n$ gets $m\in\cM$, while $R_n$
			            gets $c\in\cC$, returning $\bot$ or $m'\in\cM$.
		      \end{itemize}
	\end{itemize}
\end{dfn}

\begin{ntn}
	Let $S$ and $R$ be interactive algorithms as in \Cref{def:commitment
		protocol}.\begin{itemize}
		\item	We will write $\alg{Com}_S^R(m)$ for the output of $S$
		      in the commit phase with $S$ getting input $m\in\cM$, or $\bot$ if $R$
		      returns $\bot$.
		\item We will write $\alg{Rev}_S^R(m, c)$
		      for the output of $R$ in the reveal phase with $S$ getting input
		      $m\in\cM$ and $R$ getting input $c\in\cC$.

		      Where $S$ and $R$ are clear, we may omit the respective annotations.
	\end{itemize}
\end{ntn}

\noindent
We would like the commitment scheme to be correct, in that when the parties
behave honestly according to the protocol, the receiver returns the correct
message. Formally:
\begin{dfn}
	A commitment protocol $(S_n,R_n)$\footnote{When $n$ is unbound, we use this
		notation to indicate a family of pairs $\{(S_n,R_n):n\in\NN\}$; when $n$ is bound it refers
		to the specific pair $(S_n,R_n)$.} is \emph{correct} if for all $n\in\NN$ and
	$m\in\cM$, \[
		\Pr[\alg{Rev}_{S_n}^{R_n}(m, \alg{Com}_{S_n}^{R_n}(m)) = m] = 1.
	\]
\end{dfn}

\noindent
Given a commitment protocol $(S_n,R_n)$, we should be able to define a family of
algorithms for our rock-paper-scissors game as follows. Let $\cM = \{R,P,S\}$
and let $W: (\bot\sqcup\cM)^2\rightarrow\{1,0,-1,\bot\}$ compute whether the
first argument beats, ties, or loses to the second, propagating any $\bot$s.

% TODO: the notation here is a little ambiguous; in particular it's not completely
% clear who has views into what. We could clean it up at the cost of notational
% overhead,but it's also pretty clear from context.
\begin{prot}{Rock-Paper-Scissors}\label{prot:rock-paper-scissors}
	\begin{enumerate}[itemsep=-0.2em]
		\item $A_n$ receives input $a\in\cM$; $B_n$ receives input $b\in\cM$.
		\item $A_n$ acts as $S_n$ and $B_n$ as $R_n$ to compute $c_a = \alg{Com}_{S_n}^{R_n}(a)$.
		\item $A_n$ acts as $R_n$ and $B_n$ as $S_n$ to compute $c_b = \alg{Com}_{S_n}^{R_n}(b)$.
		\item $A_n$ acts as $S_n$ and $B_n$ as $R_n$ to compute $a' = \alg{Rev}_{S_n}^{R_n}(a,c_a)$.
		\item $A_n$ acts as $R_n$ and $B_n$ as $S_n$ to compute $b' = \alg{Rev}_{S_n}^{R_n}(b,c_b)$.
		\item $A_n$ returns $W(a,b')$.
		\item $B_n$ returns $W(a',b)$.
	\end{enumerate}
\end{prot}

\begin{ntn}
	Given some fixed commitment protocol, we will write
	$\alg{RPS}_{A}^{B}(a,b)$ for the results returned by $A$ and $B$,
	respectively. If $A$ or $B$ are honest, we will omit the corresponding
	annotation.
\end{ntn}

\noindent
As with commitment, we can define correctness of this protocol.
\begin{dfn}
	\Cref{prot:rock-paper-scissors} is \emph{correct} relative to a commitment
	protocol $(S_n,R_n)$ if for all $a,b\in\{R,P,S\}$,
	\[
		\Pr[\alg{RPS}(a, b) = (W(a,b), W(a,b))] = 1.
	\]
\end{dfn}

\begin{prop}
	\Cref{prot:rock-paper-scissors} is correct relative to any correct commitment
	protocol.
\end{prop}

\begin{proof}
	Fix a correct commitment protocol. Then \begin{align*}
		 & \Pr[\alg{RPS}(a,b) = (W(a,b),W(a,b))]                                     \\
		 & = \Pr[W(a,b') = W(a,b)\text{ and }W(a',b) = W(a,b)]                       \\
		 & = \Pr[W(a,b') = W(a,b)]\cdot\Pr[W(a',b) = W(a,b)]                         \\
		 & \geq \Pr[b'=b]\cdot\Pr[a'=a]                                              \\
		 & = \Pr[\alg{Rev}(b,c_b)=b]\cdot\Pr[\alg{Rev}(a, c_a) = a]                  \\
		 & = \Pr[\alg{Rev}(b,\alg{Com}(b))=b]\cdot\Pr[\alg{Rev}(a,\alg{Com}(a)) = a] \\
		 & = 1.\qedhere
	\end{align*}
\end{proof}

\noindent
Furthermore, at least in this case, it was easy to define notions of correctness
that compose. Our task now is to define security of commitment and
rock-paper-scissors such that, whenever a commitment scheme is secure,
\Cref{prot:rock-paper-scissors} is likewise secure.

\section{Game-Based Security}

In \emph{game-based} approaches to security, we define security by determining
the winner of an abstract game. Here, we encode specific properties we want the
algorithm to have, and say that an adversary wins the game if they can break the
property. In standard approaches to
commitment\footnote{See~\cites[Section 4.4.1]{goldreich-2001}.}, there are two
desirable properties. \emph{Hiding} means that the receiver should not learn
anything about the message until the reveal phase. \emph{Binding} means that the
sender should not be able to trick the receiver into anything other than the
committed message. Formally:

\begin{dfn}\label{def:game commitment}
	A commitment scheme $(S_n, R_n)$ is \emph{game-secure} if the following hold.
	\begin{itemize}
		\item \emph{Hiding:} consider the following game against a family of
		      adversaies $R'_n$.
		      \begin{game}\label{game:hiding}
			      \item $R'_n$ outputs $m_0,m_1\in \cM$.
			      \item A random bit $b\in\{0,1\}$ is chosen; $m_b$ is given to $S_n$.
			      \item $S_n$ and $R'_n$ participate in the commit phase.
			      \item $R'_n$ outputs a guess $b'\in\{0, 1\}$. $R'_n$ wins if $b' =
				      b$.
		      \end{game}
		      A commitment scheme is \emph{hiding} if for any family of
		      probabalistic polynomial-time algorithms $R'_n$, \[
			      \Pr[R'_n\text{ wins \Cref{game:hiding}}] \leq \frac{1}{2} + \negl.
		      \]
		      The idea is that $R'_n$ participates in the commit phase for a randomly
		      chosen message $m_b$, and then tries to guess $b$; they should be able
		      to guess no more than negligibly\footnote{A function is \emph{negligible},
			      written $\negl$, if it is asymptotically smaller than any rational
			      function in $n$.} better than random.
		\item \emph{Binding:} consider the following game against a family of
		      adversaires $S'_n$.
		      \begin{game}\label{game:binding}
			      \item $S'_n$ outputs $m\in\cM$.
			      \item $S'_n$ and $R_n$ participate in the commit phase.
			      \item A random bit $b\in\{0,1\}$ is chosen and given to $S'_n$.
			      \item $S'_n$ and $R_n$ participate in the reveal phase.
			      \item If $b = 0$, $S'_n$ wins if $R_n$ outputs $m$. If $b = 1$,
			      $S'_n$ wins if $R_n$ outputs any $m'\notin \{m, \bot\}$.
		      \end{game}

		      A commitment scheme is \emph{binding} if for any family of
		      probabalistic polynomial-time algorithms $S'_n$, \[
			      \Pr[S'_n\text{ wins \Cref{game:binding}}] \leq \frac{1}{2} + \negl.
		      \]
		      The idea is that $S'_n$ first makes a commitment, and then learns
		      whether they want to lie to $R_n$; they should be able to do no more
		      than negligibly better than guessing which of the two messages to
		      commit to before learning the random bit.
	\end{itemize}
\end{dfn}

\noindent
Similarly, we can define security of \Cref{prot:rock-paper-scissors} by having
the adversary play against an honest party who moves according to some
probability distribution.

\begin{dfn}
	\Cref{prot:rock-paper-scissors} is \emph{game-secure} relative to a commitment
	protocol $(S_n,R_n)$ if the following hold for any probability distribution
	$P$ on $\cM$:
	\begin{itemize}
		\item \emph{A-security}: For any family of PPT\footnote{Probabalistic
			      polynomial-time, though this definition can be made relative to any class
			      of adversarial algorithms.} algorithms $A'_n$,\[
			      \Pr[\pr_2(\alg{RPS}_{A'_n}(a, b)) = 1] \leq \max_{m\in\cM}P(m) + \negl,
		      \]
		      where the randomness is over uniform choice of $a$ and choice of $b$
		      according to $P$.
		\item \emph{B-security}: For any family of PPT algorithms $B'_n$,\[
			      \Pr[\pr_1(\alg{RPS}^{B'_n}(a, b)) = -1] \leq \max_{m\in\cM}P(m) + \negl,
		      \]
		      where the randomness is over choice of $a\in\cM$ according to $P$ and
		      uniform choice of $b$.
	\end{itemize}
\end{dfn}

\noindent
Observe that when the adversary controls $A$, we care only that $B$ outputs a
fair view of the game, and when the adversary controls $B$, we only care that
$A$ outputs a fair view of the game: we can never prevent the adversary from
just outputting that they win.

\vspace{1em}

Surprisingly, as we now show, it does not hold that \Cref{prot:rock-paper-scissors} is
game-secure relative to any game-secure commitment scheme.

Let $f:\bin^*\rightarrow\bin^*$ be a \emph{one-way permutation}\footnote{That such functions exist is a
	standard cryptographic assumption; see any introductory textbook, for
	example~\cite[Section 7.1]{katz-lindell-2014}.}, i.e. an injective function
which is easy to compute but hard to invert. Formally,
this means that\begin{itemize}
	\item $f$ is poly-time computable;
	\item for any family of PPT algorithms $f'_n$, \[
		      \Pr_{x\leftarrow\bin^n}[f(f'_n(f(x))) = f(x)] \leq \negl.
	      \]
\end{itemize}

Let $h: \bin^*\rightarrow\ZZ_3$ be a \emph{ternary\footnote{Typically, by
		hard-core predicate we mean a function which outputs a Boolean; we extend the
		notion for the case of rock-paper-scissors.} hard-core predicate}\footnote{If
	one-way permutations exist, then so too do one-way permutations with hard-core
	predicates~\cite{yao-1982}.} of $f$, i.e., a
function which is easy to compute, but hard to compute ``on $f$,'' in that
\begin{itemize}
	\item $h$ is poly-time computable;
	\item for any family of PPT algorithms $h'_n$, \[
		      \Pr_{x\leftarrow\bin^n}[h'_n(f(x)) = h(x)] \leq \frac{1}{3} + \negl.
	      \]
\end{itemize}

\begin{prot}{$(f,h)$-Commitment}\label{prot:commitment}
	\newline
	\emph{Commit:}
	\begin{enumerate}[itemsep=-0.2em,topsep=-0.2em]
		\item $S_n$ gets $m\in\{R,P,S\}$ and interprets as an element of $\ZZ_3$.
		\item $S_n$ picks $x\in\bin^n$ uniformly at random.
		\item $S_n$ sends $(f(x), h(x) + m)$ to $R_n$.
		\item $S_n$ returns $(f(x), h(x) + m)$.
		\item $R_n$ returns $\top$.
	\end{enumerate}
	\vspace{1em}
	\emph{Reveal:}
	\begin{enumerate}[itemsep=-0.2em,topsep=-0.2em]
		\item $S_n$ sends $x$ to $R_n$.
		\item $R_n$ verifies the values of $f(x)$ and $h(x) + m$.
		\item If the verification succeeds, $R_n$ returns $m$; else they return $\bot$.
	\end{enumerate}
\end{prot}

\noindent
The idea is that secrecy is guaranteed by hardness of $h$, while
bindingness is guaranteed by injectivity of $f$. Indeed:

\begin{prop}
	\Cref{prot:commitment} is game-secure.
\end{prop}
\begin{proof}We need to show two things.
	\begin{itemize}
		\item \emph{Hiding:} let $R'_n$ be a family of PPT algorithms. Make a
		      family $h'_n$ which proceeds as follows:
		      \begin{enumerate}[itemsep=-0.2em]
			      \item Receive input $y\in\bin^*$.
			      \item Run $R'_n$ to get $m_0,m_1\in\{R,P,S\}$.
			      \item Send $(y, 0)$ to $R'_n$, get back a guess $b'$.
			      \item Output $-m_{b'}$.
		      \end{enumerate}

		      If $h(x) + m_b = 0$ for some $b$, then $h'_n$ guesses $h(x)$ whenever
		      $R'_n$ guesses $b$. However, since $h(x)$ must look uniformly
		      distributed, this occurs negligibly close to $\frac{2}{3}$ of the
		      time. Hence since $h'_n$ guesses right no more than negligibly more
		      than $\frac{1}{3}$ of the time, $R'_n$ guesses right no more than
		      negligibly more than $\frac{1}{2}$ of the time.
		\item \emph{Binding:} By injectivity of $f$, there is a unique $x$ such that
		      $f(x)$ is committed. Once $R_n$ gets this unique $x$, they can
		      deterministically verify $f(x)$ and $h(x)+m$, returning $\bot$ if this
		      fails. \qedhere
	\end{itemize}
\end{proof}

\noindent
However, \Cref{prot:rock-paper-scissors} is not game-secure relative to
\Cref{prot:commitment}. The problem is that \Cref{prot:commitment} is
\emph{malleable}, in that the receiver can compute the commitment of a message
related to the message committed by the receiver. This does not violate secrecy,
as the receiver still cannot learn anything about the message from this new
computed commitment. In particular, to win at rock-paper-scissors, Bob only
needs to take Alice's commitment $(y, z) = (f(x), h(x) + m)$ and return $(y,
	z+1) = (f(x), h(x) + m + 1)$, which is a valid commitment to $m+1$.

Realizing this, we could now add non-malleability to the list of security
properties in \Cref{def:game commitment}. However, this example reveals a
broader issue with game-based security definitions: they rely on ad-hoc
specifications of security properties, and we need to trust that we have thought
hard enough to ensure that the properties we have specified are enough. For this
reason, there are no general composition theorems for game-based security, and
so large composite protocols of the kind used in real-world applications have to
be proven secure by hand. In the next section, we outline a more principled
approach.


\section{Simulation-Based Security}

In \emph{simulation-based} approaches to security, we define security by
comparing a protocol in the real world to an ideal world in which the desired
resource is produced by a trusted black-box.
