A theory of cryptography should define at least four things: computation,
protocols, adversarial behavior, and security. A major advantage of categorical
models of cryptography is that they conveniently separate these issues. In
particular, we have some underlying category of computations, while we represent
categories of protocols with functorial constructions on categories; as such,
our notions of interaction and security are completely independent of the
underlying model of computation.

[todo: lots more intro,
cite \cite{broadbent-karvonen-2022};
categorical crypto theories~\cite{hines-2020,pavlovic-2012,pavlovic-2014,stay-vicary-2013},
caterogies for specific crypto protocols~\cite{bkm-2019, bmr-2019}; categorical
qm
\cite{abramsky-coecke-2004,coecke-perdrix-2012,heunen-vicary-2014,coecke-kissinger-2017,chitambar-gour-2019}]

\section{Computation}

The categorical theory of computation is well-developed, going back at least to
the work of Jim Lambek and several contemporaries around the
1970s~\cite{lambeck-1974,lambeck-1980,lawvere-1969,seely-1984}. The essential
idea generalizes~\Cref{ex:functional programming}: objects are types
and morphisms are typed computations. The most disciplined approach is to
consider the categorical structure needed to model certain forms of computation, so that
for instance models of simply typed computation are \emph{bicartesian closed
categories}~\cite{lambeck-1974}, of linear computation are \emph{star-autonomous
categories}~\cite{seely-1989}, of quantum computation are \emph{compact-closed
categories}~\cite{abramsky-coecke-2004}, and of probabilistic computation are \emph{Markov
categories}~\cite{fritz-2020}. We will not review this approach here. Instead,
our focus will be on constructing specific categorical models of forms of
computations of interest to cryptographers.

\subsection{Deterministic Computation}

We would like a category of deterministic computations to have computable
functions as morphisms. However, the natural choice, taking sets as objects and
computable functions as morphisms, is actually not yet precise. The first issue
is that there are several distinct notions of computability on uncountable sets.
Each such notion forms a category, but formal definitions are outside our scope,
as cryptographers tend not to care about uncountable sets anyway\footnote{These
issues are studied in the field of \emph{computable analysis}; see for instance
the PhD thesis of Andre Bauer~\cite{bauer-2000}.}.

We can resolve this issue simply, by limiting ourselves to finite sets, in which
case every function is computable (simply by a lookup table):

\begin{dfn}[category of finite sets]
  The \emph{category of finite sets}, $\scat{FinSet}$, has finite sets as
  objects and functions as morphisms.
\end{dfn}

However, we often want to work with larger input spaces. The natural guess is to
take countable sets and computable functions. The issue here is one of encoding:
there is a canonical notion of computability on the set of finite binary
strings, but elements of arbitrary sets do not generally have canonical
encodings as binary strings. We could solve this issue by limiting
ourselves to working only with binary strings:
\begin{dfn}[category of computable binary functions]
  The \emph{category of computable binary functions} \scat{BinComp} has sets of binary strings
  $A\subseteq\bin^*$ as objects and computable functions as morphisms.
\end{dfn}

In practice, however, we like to think of computations as working over arbitrary
sets, which in particular may have more algebraic structure than sets of binary
strings. Our strategy, following~\cite{pavlovic-2014}, will be to work over sets
with fixed binary encodings.
\begin{dfn}[binary-encoded set]
  A \emph{binary-encoded set} is a set $X$ together with an injection
  $\denote{-}_X: X\to\bin^*$, called the \emph{encoding}.
\end{dfn}

Note that every binary-encoded set is finite or countable; as such, we avoid the
issues with uncountable sets mentioned above.

\begin{ntn}
  When the context is clear, we will generally drop the subscript of
  $\denote{-}$. We write $\denote{X}$ for the image of $\denote{-}_X$, i.e.
  $\denote{X} = \{s\in\bin^*: s = \denote{x}\text{ for some }x\in X\}$.
\end{ntn}

Given a function $f: X\to Y$ of binary-encoded sets, we can define a function
  \begin{align*}
    \denote{f} \colon \denote{X} &\to \denote{Y}\\
    \denote{x} &\mapsto \denote{f(x)}.
  \end{align*}
This is well-defined exactly because $\denote{-}_X$ is injective.

\begin{dfn}[category of computable functions]
  A function $f: X\to Y$ of binary-encoded sets is \emph{computable} if
  $\denote{f}$ is computable. The \emph{category of computable functions},
  \scat{Comp}, has binary-encoded sets as objects and computable functions as
  morphisms.
\end{dfn}

It needs to be shown that this is a category. First, the identities
$1_X$ are computable, as $\denote{1_X} = 1_{\denote{X}}$ is computable. Second,
the composite of computable functions is computable, as the composition of
computable binary functions is computable, and composition is preserved by
$\denote{-}$. As this argument indicates, there is a functor $\denote{-}:
\scat{Comp}\to\scat{BinComp}$; in fact this functor is an \emph{equivalence of
categories}. Nevertheless, the expanded perspective provided by $\scat{Comp}$ will be
convenient.

% [TODO: SMC structure]

Finally, we now define a symmetric monoidal structure on \scat{Comp}.
In particular, for two binary-encoded sets $X$ and $Y$, we would like to define
the product $X\otimes Y$ as the set $X\times Y$, but it is unclear what
$\denote{-}_{X\times Y}$ should be. We first fix an injective pairing map
$\<-,-\>: \bin^*\times\bin^*\to \bin$ which is efficiently computable\footnote{%
  One such map is computed as follows: given inputs $(m,n)$, start by encoding the
  length of $m$ in $2\log\log m$ bits: first write a bit of the length, then
  write a $1$ if the length continues and a $0$ if it doesn't. Now knowing the
  length of $m$, we can append the binary representation of $m$ and then $n$,
  which takes $O(\log m + \log n) = O(\log (mn))$ bits. Since $\log\log m =
  O(\log m)$, in total this algorithm takes $O(\log(mn))$ bits, and just writes
  across the tape, hence is computable in linear time.
}. We can then define $\denote{(x, y)} = \<\denote{x}, \denote{y}\>$; it is a
standard check that this defines a symmetric monoidal structure inherited from
$\scat{Set}$\footnote{
  Here is a more abstract way to see this. A suitable pairing function $\<-,-\>$
  turns $\{0,1\}$ into an internal commutative monoid in $\scat{Set}$. In other
  work, we show that the category of subobjects of any internal monoid is a
  monoidal category~\cite{shahar-zdancewic-2024}. The construction here is
  approximately an application of that general theorem.
}.

\subsection{Probabilistic Computation}

Again, there is some subtelty with probabilistic computation. Even in the case
of finite sets, not every stochastic function is computable by algorithms with
access to fair coin flips\footnote{
  We believe this is a slight conceptual problem with the strategy
  of~\cite[Section 6]{broadbent-karvonen-2022}, which models unbounded
  probabilistic computation in the category of finite sets and stochastic
  functions: this category is too powerful to reasonably model computation. This
  does not pose a technical issue in their specific example.
}. However, there is again a standard notion of computable stochastic function
of binary strings, so we can proceed much as before, defining:
\begin{dfn}[category of computable stochastic functions]
  The category \scat{BinCompStoch} has sets of binary strings as objects and
  computable stochastic functions as morphisms.

  A stochastic function $f:X\to Y $ between binary-encoded sets is
  \emph{computable} if $\denote{f}$ is computable. The \emph{category of
  computable stochastic functions} \scat{CompStoch} has binary-encoded sets as
  objects and computable stochastic functions as morphisms.
\end{dfn}

Again, it needs to be shown that this is a category. The identities are
computable (and stochastic, since every determinstic function is stochastic),
and composition commutes with $\denote{-}$, so the composite of computable
functions is computable. Furthermore, this category is symmetric monoidal, with
pairing of encodings as in \scat{Comp}.

We give a more abstract characterization of this category. There
are only countably many computable probability distributions on $\bin^*$, since
there are only countably many Turing machines. Fix a choice $\varphi$ of
bijection witnessing this fact. Note further that any probability distribution
$P$ on a binary-encoded set $X$ induces a probability distribution
$\denote{P}$ on $\bin^*$ by \[
  \Pr_{s\from \denote{P}}[s = s_0] = \Pr_{x\from P}[\denote{x} = s_0].
\]
There is now a monad $G_c: \scat{Comp}\to\scat{Comp}$, which we call the
\emph{computable Giry monad}, which takes any binary-encoded set $X$ to the set
of computable probability distributions on $X$, i.e. those such that
$\denote{P}$ is a computable probability distribution on $\bin^*$, with encoding
given by $\denote{P}_{G_c X} = \varphi(\denote{P}_X)$. Given $f: X\to Y$ and
$P\in G_c X$, we define the probability distribution $G_c f(P)$ on $Y$ by
\[
  \Pr_{y\from G_c f(P)}[y = y_0] = \Pr_{x\from P}[f(x) = y_0].
\]
The unit of $G_c$ is the function $X\to G_c X$ taking $x$ to the point
distribution at x. The multiplication is the function $\mu_X: G_c G_c X\to G_c X$
acting by summation: given a probability distribution $Q$ on $G_c X$, we define
a distribution $\mu_X (Q)$ on $X$ by \begin{equation}\label{eqn:giry-sum}
  \Pr_{x\from \mu_X(Q)}[x = x_0] = \sum_{P_0\in G_c X} \Pr_{P\from Q}[P =
  P_0]\Pr_{x\from P}[x = x_0],
\end{equation}which converges because $Q$ is a probability distribution. The proofs of
functorality and the monad laws as exactly as for the ordinary Giry
monad~\cite{giry-1982}, so we do not give them here. Now \scat{CompStoch} is in
fact (isomorphic to) the Kleisi category of $G_c$.

\subsection{Efficient and Effectful Computation}

Suppose that we are given some wide subcategory \scat{EffBin} of \scat{BinComp},
for instance that of poly-time computable maps. We can define the category
\scat{EffComp} of efficient computations as the wide subcategory of \scat{Comp}
consisting of morphisms $f$ whose encodings $\denote{f}$ are in $\scat{EffBin}$:
this is the \emph{preimage} of $\scat{EffBin}$ under the functor $\denote{-}$.

\begin{dfn}
  The category \scat{P} of poly-time computable maps is the wide subcategory
  of $\scat{Comp}$ consisting of those morphisms $f$ such that $\denote{f}$ is
  poly-time computable.
\end{dfn}

Similarly, suppose that we are give some wide subcategory of
\scat{BinCompStoch}, for instance that of poly-time computable stochastic maps.
We can similarly define the cateogry \scat{EffCompStoch}.

\begin{dfn}
  The category \scat{PPT} of poly-time computable stochastic maps is the wide is
  the wide subcategory of $\scat{CompStoch}$ consisting of those morphisms $f$
  such that $\denote{f}$ is probabilistic poly-time-computable.
\end{dfn}

In general, we can perform this construction for any complexity class $C$ which
is closed under composition.

Even more generally, let \scat{Bin} be the category of sets of binary strings and
(maybe uncomputable) set-functions between them. Let \scat{Enc} be the category
of binary-encoded sets and (maybe uncomputable) set-functions between them. Then
$\denote{-}$ is an equivalence of categories $\scat{Enc}\simeq \scat{Bin}$.

Now let \scat{EffBin} be any subcategory of \scat{Bin}. Then the \emph{category
of efficient computations} \scat{Eff} is the subcategory of \scat{Enc}
consisting of morphisms $f$ such that $\denote{f}$ is in \scat{EffBin}, i.e. the
preimage of \scat{EffBin} under $\denote{-}$. Finally, let $T$ be any monad on
\scat{Enc} which restricts to a monad on \scat{Eff}. Then the \emph{category of
efficient $T$-computations} is the Kleisi category of the restriction of $T$ to
\scat{Eff}. When $T$ is symmetric lax monoidal, this category is symmetric
monoidal.

\begin{ex}
  Each example in the previous three sections is a special case of this
  construction.
  \begin{itemize}
    \item When $\scat{EffBin}$ consists of computable functions and $T$ is the identity
      monad, we recover \scat{Comp}.
    \item When $\scat{EffBin}$ consists of computable functions and $T$ is the
      computable Giry monad, we recover \scat{CompStoch}.
    \item When $\scat{EffBin}$ consists of poly-time computable functions and $T$
      is the identity monad, we recover \scat{P}.
    \item When $\scat{EffBin}$ consists of poly-time computable functions and $T$
      is the \emph{poly-time Giry monad}, which sends a set $X$ to the set of
      poly-time computable probability distributions on $X$, we recover
      \scat{PPT}.
  \end{itemize}
\end{ex}

The point is that for any notion of efficient computation, and any notion of
computational effect (since effects are generally
monadic~\cite{wadler-thiemann-2003}), as long as the effect can be efficiently
represented, we can use the machinery of binary-encoded sets to define a
category of efficient computations carrying the given effect.

\subsection{Quantum Computation}

While an complete introduction to quantum computation is outside our scope, we
can sketch a categorical perspective; a standard introduction
is~\cite{nielsen-chuang-2010}. The \emph{category of quantum computations}
\scat{FinHilb} is the category of finite-dimensional Hilbert spaces over $\CC$ and
linear maps. Since nontrivial complex Hilbert spaces have
uncountably many vectors, we cannot directly model this category using the
machinery of the previous section, as there is no way to encode a complex
Hilbert space as an object of \scat{Bin}. If we had developed a more general
theory relying on a notion of computability over uncountable sets, then we could
now unify these perspectives; indeed, there have been several attempts to
monadically embed quantum computation into classical
calculi~\cite{altenrich-green-2009,abramsky-2017}. As we have chosen not to
develop such a general theory, in this section we will treat Hilbert spaces as
our primitive object.

A \emph{quantum computation} is a sequence of unitary transformations and
\emph{measurements}. There are several ways to provide categorical semantics to
quantum measurement; we follow~\cite{heunen-vicary-2014}.

Let $I$ be the one-dimensional Hilbert space. Note that the maps $I\to I$
correspond to choices of scalars $\lambda\in\CC$; as such, we say that a
\emph{scalar} is a map $I\to I$. Given a Hilbert space $V$, a \emph{state} is a
map $I\to V$, so that a state is determined by a choice of vector in $V$. If
$I\xto{a} V$ and $I\xto{b} V$ are states, then the projection of $a$ onto $b$
has amplitude \[
  I\xto{a}V\xto{b^\dag} I,
\]where $(-)^\dag$ denotes the adjoint; the corresponding element of $\CC$ is
the inner product $\<b,a\>$. Now the \emph{Born rule} of quantum mechanics
asserts that the probability of measuring the outcome $b$ from the state $a$ is
$|\<b, a\>|^2$. Categorically, if $I\xto{a,b} V$ are states, then the
\emph{probability of measuring $b$ from the state $a$} is the scalar \[
    I\xto{a}V\xto{b^\dag} I\xto{b} V\xto{a^\dag} I.
  \]

This is just a brief sketch of a very rich theory; see especially the work of
Bob Coecke such
as~\cite{abramsky-coecke-2004,coecke-perdrix-2012,coecke-kissinger-2017}, or the
book by Heunen and Vicary~\cite{heunen-vicary-2014}. The key point is that any
fully categorical treatment of cryptography should obtain quantum cryptography as
a special case.

\section{Protocols}

The categorical semantics of interactive computation---in particular, of
protocols---originates from the study of quantum cryptography, especially of
so-called \emph{resource theories}~\cite{coecke-2016}. The idea is to start with
some underlying SMC $\cat{C}$ of computations---fixed throughout this
section---and to construct a category of ``protocols built from computations in
$\cat{C}$.'' Exactly which functor we choose depends on what we want our
protocols to look like.

In all these categories, the basic idea is that we will think of objects as
resources and morphisms as protocols, which convert some resources into others.
For instance, in the category $\ncomb \cat{C}$, morphisms will be ``protocols with
holes''---when instantiated with specific implementations of the resources they
are waiting for, they provide some new resource.

\subsection{Products}

While the product category is used implicitly in the definition of monoidal
categories, it is worth exploring it explicitly. Given two categories $\cat{C}$
and $\cat{D}$, the \emph{product category} $\cat{C}\times\cat{D}$ has:
\begin{itemize}
  \item as objects, pairs $(X,Y)$ of objects in $\cat{C}$ and $\cat{D}$;
  \item as morphisms $(X,Y)\to (X',Y')$, pairs $(f,g)$ of morphisms so that $f:
    X\to X'$ and $g: Y\to Y'$;
  \item composition and identities defined componentwise.
\end{itemize}

When $\cat{C}$ and $\cat{D}$ are categories of computations, we think of
$\cat{C}\times\cat{D}$ as a category of non-interfering parallel computations: a
computation in $\cat{C}\times\cat{D}$ is a computation in $\cat{C}$ and a
computation in $\cat{D}$, but they cannot interact.

\subsection{States}

In the symmetric monoidal category \scat{Set}, the morphisms $\{*\}\to X$
are in natural correspondence with the elements of $X$, by the bijection \[
  (*\mapsto x) \mapsto x.
\]
Similarly, in the symmetric monoidal category $\scat{Vect}_\kk$, the morphisms
$\kk\to V$ are in natural correspondence with vectors in $V$, since such maps
are determined by their action on the vector $1\in\kk$. This pattern holds more
generally, motivating the following definition.

\begin{dfn}[state]
  A \emph{state} or \emph{generalized element} of $\cat{C}$ is a morphism $I\to
  X$ for some object $X$.
\end{dfn}

As we know, it is easy to recognize states string-diagramatically: they are
downward-pointing triangles.

\begin{dfn}[resource theory of states]
  The \emph{resource theory of states} $\state{\cat{C}}$ is the category whose objects
  are states in $\cat{C}$ and whose morphisms $(I\xto{s}X)\to (I\xto{t}Y)$ are
  maps $X\xto{f} Y$ such that $fs = y$. Composition is as in $\cat{C}$.
\end{dfn}

When $\cat{C}$ is interpreted a category of types of resources and conversions
between them, we can think of $\state{\cat{C}}$ states as a category
of specific resources and of conversions between them, forgetting the type
information.

The resource theory of states has a canonical symmetric monoidal structure
induced by that of $\cat{C}$: the tensor product of states $I\xto{s} X$ and
$I\xto{t} Y$ is just the state $I \to X\otimes Y$ given by\footnote{
  It may worry the careful reader that there are two seemingly distinct, albeit
  coherently naturally isomorphic, morphisms this diagram could represent: \[
    I\xto{\lambda_I^{-1}} I\otimes I\xto{s\otimes t}X\otimes Y\quad\text{and}\quad 
    I\xto{\rho_I^{-1}} I\otimes I\xto{s\otimes t}X\otimes Y.
  \]
  Fortunately, it is a non-obvious but standard result of Kelly that $\lambda_I
  = \rho_I$ in any SMC~\cite{kelly-1964}, so these morphisms agree.
}
\[
        \begin{pic}
          \node[state,scale=.75] (f) at (0,0) {$s$};
          \draw (f.north) to ++(0,.6) node[left] {$X$};
          \node[state,scale=.75] (g) at (.7,0) {$t$};
          \draw (g.north) to ++(0,.6) node[right] {$Y$};
        \end{pic},
\]while the tensor product of morphisms is just their tensor in $X$. The unit is
the state $1_I$, while the associator and unitor are inherited from $\cat{C}$.

It will be useful to be a little more general. Let $F: \cat{D}\to\cat{C}$ be a
lax monoidal functor. Then an \emph{$F$-state} is a map $I\to FX$ in $\cat{C}$ for some object
$X\in\cat{D}$. The \emph{resource theory of $F$-states} $\state{F}$ is the category whose
objects are $F$-states and whose morphisms $(I\xto{s} FX)\to (I\xto{t} FY)$ are
maps $X\xto{f}Y$ in $\cat{D}$ such that $(Ff)s = t$\footnote{
  With a little more machinery: $\state{F}$ is the \emph{category of elements}
    of the functor $\cat{D}\xto{F}\cat{C}\xto{C(I, -)}\scat{Set}$. The
    category of elements of any lax monoidal functor has a canonical monoidal
    structure on it induced by that of the codomain; this is the monoidal
    structure with which we endow $\state{F}$. Observe the similarity of the
    tensor in $\state{F}$ with the coherence map for the functor $C(I, -)$
    from \Cref{ex:monoidal-functors}.
  }. Note what then $\cat{C} = \cat{D}$ and $F = 1_\cat{C}$, we recover
  $\state{\cat{C}}$.

We are especially interested in the category
$\state{\cat{C}^2\xto{\otimes}\cat{C}}$. Objects in this category are morphisms
$I\to X\otimes Y$ in $\cat{C}$, which we can think of as \emph{joint states}.
When $\cat{C} = \scat{Set}$, every joint state is \emph{independent}, in that it
splits into the tensor of two morphisms $I\to X$ and $I\to Y$, but in more
complicated categories like \scat{PPT} or \scat{Hilb} this may fail, representing a
kind of \emph{entanglement}. In this way, we can express the idea that two
parties $A$ and $B$ have a shared uniform random key by the map $I\to X\otimes
X$ in \scat{PPT} that sends $*$ to a uniform random choice of pairs $(k, k)$ for
$k\in X$. This map does not split into a pair of stochastic maps $I\to X$ and $I\to X$.

More generally, we would like to model computations on $n$-party states via the
category $\state{\cat{C}^n\xto{\otimes^{n-1}}\cat{C}}$, where the $i$th copy of
$\cat{C}$ represents computations taken by the $i$th party in the computation.
There is a choice of associativity to be made, but any choice yields an
isomorphic category, so we will not worry about it here.

% \section{Paths Not Taken}

% - functorality
% - internalization of owf/indistinguishability/etc
